# -*- coding: utf-8 -*-
"""digital image project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17gbm9Kmc69BJ9yfUoxB3LkswLuKQQq_Y

# Image Processing Project README

## Project Overview
This project implements a Python-based image processing pipeline using OpenCV in Google Colab. It applies brightness and contrast adjustment, Gaussian blur, Non-local Means denoising, Canny edge detection, and Harris corner detection to a user-uploaded image.

## How to Run the Code
1. Open this notebook in Google Colab.
2. Execute all cells in sequence.
3. Upload an image (`.jpg`, `.png`, or `.tif`) when prompted in Cell 5.
4. Download the processed images as a ZIP file from Cell 7.

## Techniques Used
- **Brightness Adjustment**: Scales pixel values to adjust image brightness.
- **Contrast Adjustment**: Uses CLAHE to enhance contrast in the LAB color space.
- **Gaussian Blur**: Applies Gaussian blur to reduce image detail.
- **Non-local Means Denoising**: Reduces noise while preserving details.
- **Canny Edge Detection**: Detects object boundaries using the Canny algorithm.
- **Harris Corner Detection**: Extracts corner features for object characterization.

## Known Limitations
- Requires a Google Colab environment with GPU support.
- May struggle with very large images due to memory constraints.
- Assumes input images are in BGR format (color images).
"""

# Cell 1: Install dependencies

!pip install numpy==1.25.2 opencv-python-headless==4.8.0.76

# Cell 2: Import libraries and define display function
import cv2
import numpy as np
import os
from google.colab import files
import matplotlib.pyplot as plt

def display_image(img, title="Image"):
    """
    Display an image using matplotlib.

    Args:
        img (numpy.ndarray): Image to display (BGR or grayscale).
        title (str, optional): Title of the image plot. Default is "Image".

    Returns:
        None
    """
    plt.figure(figsize=(8, 6))
    if len(img.shape) == 2 or (len(img.shape) == 3 and img.shape[2] == 1):
        # Grayscale image
        plt.imshow(img, cmap='gray')
    else:
        # Convert BGR to RGB for correct color display
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.axis('off')
    plt.show()

# Cell 3: Define core image handling functions
def load_image(file_path):
    """
    Load an image from the specified file path.

    Args:
        file_path (str): Path to the image file.

    Returns:
        numpy.ndarray: Loaded image in BGR format.

    Raises:
        FileNotFoundError: If the file does not exist.
        ValueError: If the file format is unsupported or the image cannot be loaded.
    """
    # Check if file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Image not found: {file_path}")

    # Validate file extension
    valid_exts = ['.jpg', '.jpeg', '.png', '.tif', '.tiff']
    if not any(file_path.lower().endswith(ext) for ext in valid_exts):
        raise ValueError(f"Unsupported file format. Use {', '.join(valid_exts)}")

    # Load image using OpenCV
    img = cv2.imread(file_path)
    if img is None:
        raise ValueError(f"Failed to load image: {file_path}")
    return img

def save_image(image, output_path):
    """
    Save an image to the specified file path.

    Args:
        image (numpy.ndarray): Image to save (BGR or grayscale).
        output_path (str): Path to save the image.

    Returns:
        None

    Raises:
        ValueError: If the output file format is unsupported.
    """
    # Validate output file extension
    valid_exts = ['.jpg', '.jpeg', '.png', '.tif', '.tiff']
    if not any(output_path.lower().endswith(ext) for ext in valid_exts):
        raise ValueError(f"Unsupported format. Use {', '.join(valid_exts)}")

    # Save the image using OpenCV
    cv2.imwrite(output_path, image)

# Cell 4: Define processing functions

def validate_bgr_image(image):
    """
    Validate that the input image is in BGR format (3 channels).

    Args:
        image (numpy.ndarray): Input image to validate.

    Raises:
        ValueError: If the image is not in BGR format (3 channels).
    """
    if len(image.shape) != 3 or image.shape[2] != 3:
        raise ValueError("Input image must be in BGR format (3 channels)")

def convert_to_grayscale(image, as_float=False):
    """
    Convert an image to grayscale.

    Args:
        image (numpy.ndarray): Input image in BGR format.
        as_float (bool, optional): If True, convert to float32 type. Default is False.

    Returns:
        numpy.ndarray: Grayscale image.
    """
    validate_bgr_image(image)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    if as_float:
        return gray.astype(np.float32)
    return gray

def adjust_brightness(image, scale=1.2):
    """
    Adjust the brightness of an image by scaling pixel values.

    Args:
        image (numpy.ndarray): Input image in BGR format.
        scale (float, optional): Scaling factor for brightness. Default is 1.2.

    Returns:
        numpy.ndarray: Brightness-adjusted image in BGR format.

    Notes:
        - Input validation is handled by validate_bgr_image.
    """
    validate_bgr_image(image)
    adjusted = np.clip(image.astype(np.float32) * scale, 0, 255).astype(np.uint8)
    return adjusted

def apply_histogram_equalization(image):
    """
    Apply histogram equalization using CLAHE to enhance image contrast.

    Args:
        image (numpy.ndarray): Input image in BGR format.

    Returns:
        numpy.ndarray: Contrast-enhanced image in BGR format.

    Notes:
        - Input validation is handled by validate_bgr_image.
        - Converts the image to LAB color space, applies CLAHE to the L channel,
          and converts back to BGR.
        - CLAHE (Contrast Limited Adaptive Histogram Equalization) improves local contrast.
    """
    validate_bgr_image(image)
    lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
    l_eq = clahe.apply(l)
    lab_eq = cv2.merge((l_eq, a, b))
    return cv2.cvtColor(lab_eq, cv2.COLOR_LAB2BGR)

def apply_gaussian_blur(image, kernel_size=(5,5)):
    """
    Apply Gaussian blur to reduce image detail.

    Args:
        image (numpy.ndarray): Input image in BGR format.
        kernel_size (tuple, optional): Size of the Gaussian kernel. Default is (5,5).

    Returns:
        numpy.ndarray: Blurred image in BGR format.

    Notes:
        - Input validation is handled by validate_bgr_image.
    """
    validate_bgr_image(image)
    return cv2.GaussianBlur(image, kernel_size, 0)

def apply_non_local_means_denoising(image):
    """
    Apply Non-local Means Denoising to reduce noise while preserving details.

    Args:
        image (numpy.ndarray): Input image in BGR format.

    Returns:
        numpy.ndarray: Denoised image in BGR format.

    Notes:
        - Input validation is handled by validate_bgr_image.
        - Uses OpenCV's fastNlMeansDenoisingColored with default parameters.
    """
    validate_bgr_image(image)
    return cv2.fastNlMeansDenoisingColored(image)

def apply_canny_edge_detection(image, threshold1=100, threshold2=200):
    """
    Apply Canny edge detection to extract object boundaries.

    Args:
        image (numpy.ndarray): Input image in BGR format.
        threshold1 (int, optional): First threshold for hysteresis. Default is 100.
        threshold2 (int, optional): Second threshold for hysteresis. Default is 200.

    Returns:
        numpy.ndarray: Grayscale image with detected edges.

    Notes:
        - Input validation is handled by validate_bgr_image.
        - Converts the image to grayscale before applying Canny edge detection.
        - Thresholds control edge detection sensitivity.
    """
    validate_bgr_image(image)
    gray = convert_to_grayscale(image)
    edges = cv2.Canny(gray, threshold1, threshold2)
    return edges

def detect_harris_corners(image, threshold=0.01):
    """
    Detect corners in the image using the Harris corner detection algorithm.

    Args:
        image (numpy.ndarray): Input image in BGR format.
        threshold (float, optional): Threshold for marking corners.
            Default is 0.01 (as a fraction of the maximum corner response).

    Returns:
        numpy.ndarray: Image with detected corners marked in red (BGR: [0, 0, 255]).

    Notes:
        - Input validation is handled by validate_bgr_image.
        - Converts the image to grayscale and applies Harris corner detection.
        - Corners above the threshold are highlighted in red.
    """
    validate_bgr_image(image)
    img = image.copy()
    gray = convert_to_grayscale(img, as_float=True)
    corners = cv2.cornerHarris(gray, blockSize=2, ksize=3, k=0.04)
    corners = cv2.dilate(corners, None)
    img[corners > threshold * corners.max()] = [0, 0, 255]
    return img

# Cell 5: Upload image and setup
try:
    print("Please upload an image file (jpg/png/tif)")
    uploaded = files.upload()
    if not uploaded:
        raise ValueError("No files uploaded")

    input_file = list(uploaded.keys())[0]
    input_img = load_image(input_file)
    display_image(input_img, "Original Image")

    output_dir = "processed_images"
    os.makedirs(output_dir, exist_ok=True)
    processed = input_img.copy()

except Exception as e:
    print(f"Initialization error: {str(e)}")

# Cell 6: Process the image through all steps
try:
    # Step 1: Brightness Adjustment
    bright_img = adjust_brightness(processed, scale=1.2)
    display_image(bright_img, "Brightness Adjusted")
    save_image(bright_img, os.path.join(output_dir, "1_bright.jpg"))

    # Step 2: Contrast Adjustment
    contrast_img = apply_histogram_equalization(bright_img)
    display_image(contrast_img, "Contrast Enhanced")
    save_image(contrast_img, os.path.join(output_dir, "2_contrast.jpg"))

    # Step 3: Gaussian Blur
    blurred_img = apply_gaussian_blur(contrast_img, kernel_size=(5,5))
    display_image(blurred_img, "Gaussian Blur")
    save_image(blurred_img, os.path.join(output_dir, "3_blurred.jpg"))

    # Step 4: Non-local Means Denoising
    denoised_img = apply_non_local_means_denoising(blurred_img)
    display_image(denoised_img, "Denoised (Non-local Means)")
    save_image(denoised_img, os.path.join(output_dir, "4_denoised.jpg"))

    # Step 5: Canny Edge Detection
    edges_img = apply_canny_edge_detection(denoised_img, threshold1=100, threshold2=200)
    display_image(edges_img, "Canny Edges")
    save_image(edges_img, os.path.join(output_dir, "5_edges.jpg"))

    # Step 6: Harris Corner Detection
    corners_img = detect_harris_corners(denoised_img, threshold=0.01)
    display_image(corners_img, "Harris Corners")
    save_image(corners_img, os.path.join(output_dir, "6_corners.jpg"))

    print("Processing completed successfully.")
except Exception as e:
    print(f"Processing error: {str(e)}")

# Cell 12: Download results
try:
    !zip -r processed_images.zip processed_images
    files.download('processed_images.zip')
except Exception as e:
    print(f"Download error: {str(e)}")